<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2023-Summary</title>
    <url>/2024/02/08/2023-Summary/</url>
    <content><![CDATA[<p>回首2023年，这算是这几年波澜不惊的工作生活中最跌宕起伏的一年了。这一年有刺激紧张的王者荣耀线下比赛，有几个月的不算刻苦的锻炼，有令人难以接受的薪资和晋升，以及一段“短命”的感情，总结下来今年就是感情失败，工作失败，生活马马虎虎。唯一的好消息是：又苟活了一年。</p>
<a id="more"></a>

<h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>截止到2023年底这已经是从校招出来工作的第四年了，前两年的工作中规中矩吧，第一年工作兢兢业业绩效却很差，第二年工作一般般绩效却也还可以，按照原本的计划今年年底是可以晋升（晋升才会涨工资），所以今年按时除了完成需求外其他时间基本都在开摆，万事具备，只等升级。可是天不遂人愿，想要的终究是没有等来，等来的是年终（克扣我一年的工资）五折，晋升失败，明年是否晋升，明年年终是否再次打骨折，一切都是未知数，到这里突然看不到希望了，不知道在大环境这样不好的情况出了公司还能不能找到称心的工作，不知道未来辛苦工作一年等来的又是什么，不知道中年危机之后我还能干什么。</p>
<p>之前家里人也一直在让我学习一下他们的事业需要的东西，可能是这还过去的薪资让我一直没怎么上心，心想着工作薪资怎么着也还行，结果是给我当头一棒，所以明年这个也不得不提上日程了，如果学有所成也算是一个副业了，给这微薄的薪资添砖加瓦。工作快四年了，钱没存下多少，想想还是挺失败，快奔三的人了，没点存款说出去还是有点难以启齿，以后还是省吃俭用，存点钱，多点说走就走的底气。</p>
<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>年中的时候参加了一个公司组织的王者荣耀比赛，在部门一路披荆斩棘，最后成功去线下打了比赛，并拿到了亚军，算是这平静的几年为数不多的波澜了。仔细想想这几年没怎么出去走走，周末最大的运动量可能是从床上走到厕所，感觉挺无趣的，就像我一贯的我，过着无趣的生活的死肥宅。</p>
<h2 id="感情"><a href="#感情" class="headerlink" title="感情"></a>感情</h2><p>27年来第一次谈恋爱，初恋来的快，去的也快，69天的相处好像一瞬即逝，就像是从来没发生过，几年没坐过地铁的我第一次熟悉了二号线的时间，熟悉了二号线的那一轮站点，直到分开前一天都还好好的，在她说出她父母不同意时，我感觉这一切好突然好抓马，她分别时的眼泪像是对我们这段感情做出了总结一般，在嘱咐她好好照顾自己后，我像是那慷慨赴死的将士离开了她家，现在想想当时应该好好抱抱她的，虽然并不能改变什么，但心里总觉的差了点什么。后来我才发现，我们居然连一张合照都没有，失败！！！</p>
<p>2023年是这几年最好的一年，因为遇见了她，2023年又是这几年最失败的一年，因为除了命还在好像其他的什么也没有。</p>
]]></content>
      <categories>
        <category>Annual Summary</category>
      </categories>
      <tags>
        <tag>2023</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 8 流式操作API Stream</title>
    <url>/2020/12/06/java-Stream/</url>
    <content><![CDATA[<p><code>Classes to support functional-style operations on streams of elements</code> 这是 oracle 官方对 <code>Package java.util.stream</code>包的解释，可以了解 Stream 包是对元素流的函数式操作进行支持。Stream API 是 Java8 中处理集合的关键抽象概念，可以让我们以一种类 SQL 语句从数据库查询数据的方式对集合进行操作，极大的简化了 Java 对集合处理数据的方式。</p>
<a id="more"></a>

<p><strong>Stream 和集合不同：</strong></p>
<ul>
<li>流不是存储元素的数据结构，没有存储空间。即对流的操作会产生结果，但不会修改其源。</li>
<li>惰性求值，许多流在中间处理过程中，只是对操作进行了记录，并不会立即执行，需要等到执行终止操作的时候才会进行实际的计算。</li>
<li>Stream 流是一种消耗品，在流的生存期内，流的元素只能访问一次。例子如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] strings = &#123;<span class="string">&quot;java&quot;</span>, <span class="string">&quot;Stream&quot;</span>, <span class="string">&quot;Api&quot;</span>, <span class="string">&quot;Java8&quot;</span>&#125;;</span><br><span class="line">Stream&lt;String&gt; stream = Arrays.stream(strings);</span><br><span class="line">stream.forEach(System.out::print);</span><br><span class="line">System.out.println();</span><br><span class="line">stream.forEach(System.out::print);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>如上面的语句在执行到第二句 <code>stream.forEach(System.out::print)</code> 的时候会抛出异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javaStreamApiJava8</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.IllegalStateException: stream has already been operated upon or closed</span><br></pre></td></tr></table></figure>



<h2 id="Stream-操作分类"><a href="#Stream-操作分类" class="headerlink" title="Stream 操作分类"></a>Stream 操作分类</h2><img style="zoom: 70%;" data-src="https://tva1.sinaimg.cn/large/0081Kckwgy1glfqi55wyhj31110phmz5.jpg">

<p>无状态：指元素的处理不受之前元素的影响。</p>
<p>有状态：指该操作只有拿到所有元素之后才能继续下去。</p>
<p>非短路操作：指必须处理所有元素才能得到最终结果。</p>
<p>短路操作：指遇到某些符合条件的元素就可以得到最终结果，如 A || B，只要A为true，则无需判断B的结果。</p>
<blockquote>
<p>我们也可以将中间操作称为懒操作。</p>
</blockquote>
<h2 id="流的创建"><a href="#流的创建" class="headerlink" title="流的创建"></a>流的创建</h2><ul>
<li>使用Collection下的 stream() 和 parallelStream() 方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Stream&lt;String&gt; stream = strings.stream();</span><br><span class="line">Stream&lt;String&gt; parallelStream = strings.parallelStream();</span><br></pre></td></tr></table></figure>

<ul>
<li>使用Arrays 中的静态方法 stream() ，将数组转成流</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] nums = <span class="keyword">new</span> Integer[<span class="number">10</span>];</span><br><span class="line">Stream&lt;Integer&gt; stream = Arrays.stream(nums);</span><br></pre></td></tr></table></figure>

<ul>
<li>使用Stream中的静态方法：of()、iterate()、generate()</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] strings = <span class="keyword">new</span> String[] &#123;<span class="string">&quot;java8&quot;</span>,<span class="string">&quot;Stream&quot;</span>,<span class="string">&quot;API&quot;</span>,<span class="string">&quot;operation&quot;</span>&#125;;</span><br><span class="line">Stream&lt;String&gt; stream1 = Stream.of(strings);</span><br><span class="line"></span><br><span class="line">Stream&lt;Integer&gt; stream2 = Stream.iterate(<span class="number">1</span>, i -&gt; i + <span class="number">1</span>).limit(<span class="number">5</span>);</span><br><span class="line">stream2.forEach(System.out::println);  <span class="comment">// 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line">Stream&lt;Double&gt; stream3 = Stream.generate(Math::random).limit(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>



<h2 id="流的中间操作"><a href="#流的中间操作" class="headerlink" title="流的中间操作"></a>流的中间操作</h2><table>
<thead>
<tr>
<th>操作</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>filter()</td>
<td>过滤流，过滤流中的元素，返回一个符合条件的Stream</td>
</tr>
<tr>
<td>map()</td>
<td>转换流，将给定函数应用于该流的元素的结果转换为另外一种流（mapToInt、mapToLong、mapToDouble 返回int、long、double基本类型对应的 IntStream、LongStream、DoubleStream流）</td>
</tr>
<tr>
<td>flatMap()</td>
<td>能够展平”包裹的流”，简单的说，就是合并一个或多个流成为一个新流（flatMapToInt、flatMapToLong、flatMapToDouble 返回对应的 IntStream、LongStream、DoubleStream流）</td>
</tr>
<tr>
<td>peek()</td>
<td>如同于map，能得到流中的每一个元素。但map接收的是一个Function表达式，有返回值；而peek接收的是Consumer表达式，没有返回值。（查看流中元素的数据状态）</td>
</tr>
<tr>
<td>distinct()</td>
<td>返回去重的 Stream</td>
</tr>
<tr>
<td>sorted()</td>
<td>返回一个排序的 Stream</td>
</tr>
<tr>
<td>limit()</td>
<td>返回前n个元素数据组成的 Stream</td>
</tr>
<tr>
<td>skip()</td>
<td>返回第n个元素后面数据组成的 Stream，类似 mysql 中的 offset，配合 limit() 可实现分页操作</td>
</tr>
</tbody></table>
<ul>
<li>filter()</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;java8&quot;</span>,<span class="string">&quot;Stream&quot;</span>,<span class="string">&quot;API&quot;</span>,<span class="string">&quot;operation&quot;</span>);</span><br><span class="line"> List&lt;String&gt; list = strings.stream()</span><br><span class="line">               .filter(str -&gt; str.length() == <span class="number">5</span>)</span><br><span class="line">               .collect(Collectors.toList());</span><br><span class="line">System.out.println(list); </span><br><span class="line"><span class="comment">/* [java8] */</span></span><br></pre></td></tr></table></figure>

<ul>
<li>map()</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;java8&quot;</span>,<span class="string">&quot;Stream&quot;</span>,<span class="string">&quot;API&quot;</span>,<span class="string">&quot;operation&quot;</span>);</span><br><span class="line">List&lt;String&gt; list = strings.stream()</span><br><span class="line">              .map(str -&gt; str + <span class="string">&quot;map&quot;</span>)</span><br><span class="line">              .collect(Collectors.toList());</span><br><span class="line">System.out.println(list);</span><br><span class="line"><span class="comment">/* [java8map, Streammap, APImap, operationmap] */</span></span><br></pre></td></tr></table></figure>

<ul>
<li>flatMap()</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;a,b,c&quot;</span>, <span class="string">&quot;1,2,3&quot;</span>);</span><br><span class="line">list.stream()</span><br><span class="line">  .map(s -&gt; s.replaceAll(<span class="string">&quot;,&quot;</span>, <span class="string">&quot;&quot;</span>))</span><br><span class="line">  .forEach(s -&gt; System.out.print(s+ <span class="string">&quot; &quot;</span>));</span><br><span class="line">System.out.println();</span><br><span class="line">list.stream()</span><br><span class="line">  .flatMap(s -&gt; Arrays.stream(s.split(<span class="string">&quot;,&quot;</span>))) <span class="comment">// 将每个元素转化成一个流</span></span><br><span class="line">  .forEach(s -&gt; System.out.print(s+ <span class="string">&quot; &quot;</span>));</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">abc 123 </span></span><br><span class="line"><span class="comment">a b c 1 2 3 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>peek() </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JDK 内置示例</span></span><br><span class="line">Stream.of(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>, <span class="string">&quot;four&quot;</span>)</span><br><span class="line">               .filter(e -&gt; e.length() &gt; <span class="number">3</span>)</span><br><span class="line">            .peek(e -&gt; System.out.println(<span class="string">&quot;Filtered value: &quot;</span> + e))</span><br><span class="line">             .map(String::toUpperCase)</span><br><span class="line">            .peek(e -&gt; System.out.println(<span class="string">&quot;Mapped value: &quot;</span> + e))</span><br><span class="line">             .collect(Collectors.toList());</span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">Filtered value: three</span></span><br><span class="line"><span class="comment">Mapped value: THREE</span></span><br><span class="line"><span class="comment">Filtered value: four</span></span><br><span class="line"><span class="comment">Mapped value: FOUR</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反例</span></span><br><span class="line">Stream.of(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>, <span class="string">&quot;four&quot;</span>)</span><br><span class="line">               .filter(e -&gt; e.length() &gt; <span class="number">3</span>)</span><br><span class="line">            .peek(e -&gt; System.out.println(<span class="string">&quot;Filtered value: &quot;</span> + e))</span><br><span class="line">             .peek(String::toUpperCase)</span><br><span class="line">            .peek(e -&gt; System.out.println(<span class="string">&quot;Mapped value: &quot;</span> + e))</span><br><span class="line">             .collect(Collectors.toList());</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Filtered value: three</span></span><br><span class="line"><span class="comment">Mapped value: three</span></span><br><span class="line"><span class="comment">Filtered value: four</span></span><br><span class="line"><span class="comment">Mapped value: four</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>distinct()、sorted()、limit()、skip()</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;java8&quot;</span>,<span class="string">&quot;Stream&quot;</span>,<span class="string">&quot;API&quot;</span>,<span class="string">&quot;operation&quot;</span>,<span class="string">&quot;java8&quot;</span>,<span class="string">&quot;API&quot;</span>,<span class="string">&quot;limit&quot;</span>);</span><br><span class="line">List&lt;String&gt; list = strings.stream()</span><br><span class="line">         .filter(str -&gt; str.length() &gt; <span class="number">3</span>) <span class="comment">// [java8, Stream, operation, java8, limit]</span></span><br><span class="line">         .distinct() <span class="comment">// [java8, Stream, operation, limit]</span></span><br><span class="line">         .sorted() <span class="comment">// [Stream, java8, limit, operation]</span></span><br><span class="line">         .sorted((s1,s2) -&gt; s2.compareTo(s1)) <span class="comment">// [operation, limit, java8, Stream]</span></span><br><span class="line">         .skip(<span class="number">1</span>) <span class="comment">// [limit, java8, Stream]</span></span><br><span class="line">         .limit(<span class="number">2</span>) <span class="comment">// [limit, java8]</span></span><br><span class="line">         .collect(Collectors.toList());</span><br><span class="line">System.out.println(list); <span class="comment">// [limit, java8]</span></span><br></pre></td></tr></table></figure>



<h2 id="流的终止操作"><a href="#流的终止操作" class="headerlink" title="流的终止操作"></a>流的终止操作</h2><table>
<thead>
<tr>
<th>操作</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>forEach()</td>
<td>循环操作Stream中数据</td>
</tr>
<tr>
<td>toArray()</td>
<td>返回流中元素对应的数组对象</td>
</tr>
<tr>
<td>reduce()</td>
<td>聚合操作，用来做统计，将流中元素反复结合起来统计计算，得到一个值</td>
</tr>
<tr>
<td>collect()</td>
<td>聚合操作，封装目标数据，将流转换为其他形式接收，如： List、Set、Map、Array</td>
</tr>
<tr>
<td>min()、max()、count()</td>
<td>聚合操作，最小值，最大值，总数量</td>
</tr>
<tr>
<td>anyMatch()</td>
<td>短路操作，有一个符合条件返回true</td>
</tr>
<tr>
<td>allMatch()、noneMatch()</td>
<td>所有数据都符合条件返回true；所有数据都不符合条件返回true</td>
</tr>
<tr>
<td>findFirst()、findAny()</td>
<td>短路操作，获取第一个元素；短路操作，获取任一元素</td>
</tr>
<tr>
<td>forEachOrdered()</td>
<td>按元素顺序执行循环操作(与foreach 的区别主要在并行处理上，)</td>
</tr>
</tbody></table>
<ul>
<li>toArray()</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;a,b,c&quot;</span>, <span class="string">&quot;1,2,3&quot;</span>);</span><br><span class="line">String[] array = list.stream()</span><br><span class="line">        .map(s -&gt; s.replaceAll(<span class="string">&quot;,&quot;</span>, <span class="string">&quot;&quot;</span>))</span><br><span class="line">        .toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">System.out.println(Arrays.toString(array));</span><br><span class="line"><span class="comment">// [abc, 123]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>min()、max()、count()</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; nums = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>);</span><br><span class="line"><span class="keyword">long</span> count1 = nums.stream().count();</span><br><span class="line"><span class="keyword">long</span> count2 = nums.stream().collect(Collectors.counting());</span><br><span class="line">Integer max = nums.stream().max(Integer::compareTo).get();</span><br><span class="line">Integer min = nums.stream().min(Integer::compareTo).get();</span><br><span class="line">System.out.println(count1 + <span class="string">&quot; &quot;</span> + count2 + <span class="string">&quot; &quot;</span> + max+ <span class="string">&quot; &quot;</span> + min);</span><br><span class="line"><span class="comment">// 7 7 7 1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>anyMatch()、allMatch()、noneMatch()</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> allMatch = list.stream().allMatch(i -&gt; i &gt; <span class="number">6</span>);</span><br><span class="line"><span class="keyword">boolean</span> noneMatch = list.stream().noneMatch(i -&gt; i &gt; <span class="number">10</span>);</span><br><span class="line"><span class="keyword">boolean</span> anyMatch = list.stream().anyMatch(i -&gt; i &gt; <span class="number">4</span>);</span><br><span class="line">System.out.println(allMatch + <span class="string">&quot; &quot;</span> + noneMatch +  <span class="string">&quot; &quot;</span> + anyMatch);</span><br><span class="line"><span class="comment">// false true true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>findFirst()、findAny()</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;java8&quot;</span>,<span class="string">&quot;Stream&quot;</span>,<span class="string">&quot;API&quot;</span>,<span class="string">&quot;operation&quot;</span>,<span class="string">&quot;java8&quot;</span>,<span class="string">&quot;API&quot;</span>,<span class="string">&quot;limit&quot;</span>);</span><br><span class="line">Optional&lt;String&gt; first1 = strings.stream()</span><br><span class="line">        .filter(<span class="string">&quot;java8&quot;</span>::equals)</span><br><span class="line">        .findFirst();</span><br><span class="line">System.out.println(first1.orElse(<span class="keyword">null</span>));</span><br><span class="line"></span><br><span class="line">Optional&lt;String&gt; first2 = strings.stream()</span><br><span class="line">        .filter(<span class="string">&quot;java8_2&quot;</span>::equals)</span><br><span class="line">        .findFirst();</span><br><span class="line">System.out.println(first2.orElse(<span class="keyword">null</span>));</span><br><span class="line"></span><br><span class="line">Optional&lt;String&gt; any = strings.stream()</span><br><span class="line">        .filter(<span class="string">&quot;API&quot;</span>::equals)</span><br><span class="line">        .findAny();</span><br><span class="line">System.out.println(any.orElse(<span class="keyword">null</span>));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java8</span></span><br><span class="line"><span class="comment">null</span></span><br><span class="line"><span class="comment">API */</span></span><br></pre></td></tr></table></figure>

<ul>
<li>forEach()、forEachOrdered()</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;AAA&quot;</span>,<span class="string">&quot;BBB&quot;</span>,<span class="string">&quot;CCC&quot;</span>).parallel().forEach(s-&gt;System.out.println(<span class="string">&quot;forEach:&quot;</span>+s));</span><br><span class="line">Stream.of(<span class="string">&quot;AAA&quot;</span>,<span class="string">&quot;BBB&quot;</span>,<span class="string">&quot;CCC&quot;</span>).parallel().forEachOrdered(s-&gt;System.out.println(<span class="string">&quot;forEachOrdered:&quot;</span>+s));</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* forEach() 输出不稳定，forEachOrdered()输出稳定，以为所有元素按顺序执行操作</span></span><br><span class="line"><span class="comment">  forEach:AAA</span></span><br><span class="line"><span class="comment">  forEach:CCC</span></span><br><span class="line"><span class="comment">  forEach:BBB</span></span><br><span class="line"><span class="comment">  forEachOrdered:AAA</span></span><br><span class="line"><span class="comment">  forEachOrdered:BBB</span></span><br><span class="line"><span class="comment">  forEachOrdered:CCC</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">forEach:AAA</span></span><br><span class="line"><span class="comment">forEach:BBB</span></span><br><span class="line"><span class="comment">forEach:CCC</span></span><br><span class="line"><span class="comment">forEachOrdered:AAA</span></span><br><span class="line"><span class="comment">forEachOrdered:BBB</span></span><br><span class="line"><span class="comment">forEachOrdered:CCC</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2 id="规约操作"><a href="#规约操作" class="headerlink" title="规约操作"></a>规约操作</h2><div class="note success">
            <p>Optional<t> reduce(BinaryOperator<t> accumulator)：第一次执行时，accumulator函数的第一个参数为流中的第一个元素，第二个参数为流中元素的第二个元素；第二次执行时，第一个参数为第一次函数执行的结果，第二个参数为流中的第三个元素；依次类推。</t></t></p>
          </div>

<div class="note success">
            <p>T reduce(T identity, BinaryOperator<t> accumulator)：流程跟上面一样，只是第一次执行时，accumulator函数的第一个参数为identity，而第二个参数为流中的第一个元素。</t></p>
          </div>

<div class="note success">
            <p><u> U reduce(U identity,BiFunction&lt;U, ? super T, U&gt; accumulator,BinaryOperator<u> combiner)：在串行流(stream)中，该方法跟第二个方法一样，即第三个参数combiner不会起作用。在并行流(parallelStream)中,我们知道流被fork join出多个线程进行执行，此时每个线程的执行流程就跟第二个方法reduce(identity,accumulator)一样，而第三个参数combiner函数，则是将每个线程的执行结果当成一个新的流，然后使用第一个方法reduce(accumulator)流程进行规约。</u></u></p>
          </div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">T <span class="title">reduce</span><span class="params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">reduce</span><span class="params">(BinaryOperator&lt;T&gt; accumulator)</span></span>;</span><br><span class="line"></span><br><span class="line">&lt;U&gt; <span class="function">U <span class="title">reduce</span><span class="params">(U identity,</span></span></span><br><span class="line"><span class="function"><span class="params">                 BiFunction&lt;U, ? <span class="keyword">super</span> T, U&gt; accumulator,</span></span></span><br><span class="line"><span class="function"><span class="params">                 BinaryOperator&lt;U&gt; combiner)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream.range(<span class="number">1</span>, <span class="number">5</span>).forEach(i -&gt; System.out.print(i + <span class="string">&quot; &quot;</span>));</span><br><span class="line">System.out.println();</span><br><span class="line"><span class="keyword">int</span> sum = IntStream.range(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">  .reduce((x, y) -&gt; x + y)</span><br><span class="line">  .orElse(<span class="number">0</span>);</span><br><span class="line">System.out.println(sum);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum2 = IntStream.range(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">  .reduce(<span class="number">0</span>, (x, y) -&gt; x + <span class="number">2</span> * y);</span><br><span class="line">System.out.println(sum2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum3 = IntStream.range(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">  .reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">System.out.println(sum3);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1 2 3 4 </span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">20</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h2 id="收集操作"><a href="#收集操作" class="headerlink" title="收集操作"></a>收集操作</h2><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html">java.util.stream (Java Platform SE 8 )</a></p>
</li>
<li><p><a href="https://blog.csdn.net/y_k_y/article/details/84633001">Java 8 stream的详细用法</a></p>
</li>
<li><p><a href="https://blog.ouyangsihai.cn/">欧阳思海</a> . <a href="http://blog.ouyangsihai.cn/java8-de-stream-liu-shi-cao-zuo-zhi-wang-zhe-gui-lai.html">Java8 的 Stream 流式操作之王者归来</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo</title>
    <url>/2020/12/09/hexo/</url>
    <content><![CDATA[<p>Next 美化的相关操作</p>
<a id="more"></a>



<div class="note default">
            <p>default </p>
          </div>

<div class="note primary">
            <p>primary </p>
          </div>

<div class="note success">
            <p>success </p>
          </div>

<div class="note info">
            <p>info </p>
          </div>

<div class="note warning">
            <p>warning </p>
          </div>

<div class="note danger">
            <p>danger </p>
          </div>]]></content>
      <categories>
        <category>next</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>github clone很慢或失败解决方案</title>
    <url>/2020/08/01/github-clone-failed/</url>
    <content><![CDATA[<p>最近在 GitHub clone 项目很慢或者会卡在某个地方以至于 clone 失败，或者clone 失败后会报如下错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ......</span><br><span class="line">$ 接收对象中:  13% (1283/9381), 4.21 MiB | 2.00 KiB/s        </span><br><span class="line">$ error: RPC failed; curl 18 transfer closed with outstanding <span class="built_in">read</span> data remaining</span><br><span class="line">$ fatal: 远端意外挂断了</span><br><span class="line">$ fatal: 过早的文件结束符（EOF）</span><br><span class="line">$ fatal: index-pack 失败</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="Github-clone失败解决方案"><a href="#Github-clone失败解决方案" class="headerlink" title="Github clone失败解决方案"></a>Github clone失败解决方案</h2><h3 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h3><p>对 git <code>http.postBuffer</code> 属性进行设置<br>这种方式虽然可以 clone 成功，但是速度还是很慢，速度稳定在10kb/s左右。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global http.postBuffer 524288000</span><br></pre></td></tr></table></figure>

<h3 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h3><p>使用 SSR 代理,首先打开本地 SSR 客户端 &gt; 高级设置，查看本地 Sockets5 监听端口号，例如我的 Sockets5 监听的端口号为 <code>1086</code></p>
<img alt="SSR-setting" style="zoom: 67%;" data-src="https://tva1.sinaimg.cn/large/006tNbRwgy1gadyghg8owj30qe0gqwg3.jpg">

<p>进行如下配置，然后 clone 时使用全局代理模式就可以成功并且速度很快</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global http.https://github.com.proxy socks5://127.0.0.1:1086</span><br><span class="line">$ git config --global https.https://github.com.proxy socks5://127.0.0.1:1086</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果不需要上面的配置也可以取消设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global --<span class="built_in">unset</span> http.https://github.com.proxy</span><br><span class="line">$ git config --global --<span class="built_in">unset</span> https.https://github.com.proxy</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="解决方案三"><a href="#解决方案三" class="headerlink" title="解决方案三"></a>解决方案三</h3><p>使用Github的镜像库拉取代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/blissleek/blissleek.github.io.git </span><br><span class="line"></span><br><span class="line">// 将https://github.com替换为下面的镜像地址</span><br><span class="line">https://github.com.cnpmjs.org</span><br><span class="line">https://hub.fastgit.org</span><br></pre></td></tr></table></figure>



<h2 id="Github-提交失败解决方案"><a href="#Github-提交失败解决方案" class="headerlink" title="Github 提交失败解决方案"></a>Github 提交失败解决方案</h2><div class="note danger">
            <p>在执行<code>git</code> push 命令报错：LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443</p>
          </div>

<h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global http.sslBackend <span class="string">&quot;openssl&quot;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
</search>
